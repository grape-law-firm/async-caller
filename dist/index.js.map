{"version":3,"sources":["../src/tokenBucket/index.ts","../src/asyncCaller/index.ts","../src/asyncCaller/types.ts","../src/string/removeMatterCode.ts"],"sourcesContent":["import type { TokenBucketOptions } from './types.js';\n\nexport class TokenBucket {\n  private _tokens: number;\n  private readonly _capacity: number;\n  private readonly _fillPerWindow: number;\n  private readonly _windowInMs: number;\n  private _timerId: NodeJS.Timer | null = null;\n  private readonly _waitQueue: Array<() => void> = [];\n  private readonly verbose: boolean;\n  private _nextRefillDate: Date | undefined;\n  private _ongoingForcedStop = false;\n\n  constructor(options: TokenBucketOptions, verbose: boolean = false) {\n    this.verbose = verbose;\n    this.validate(options);\n    this._capacity = options.capacity;\n    this._tokens = options.initialTokens ?? options.capacity;\n    this._fillPerWindow = options.fillPerWindow;\n    this._windowInMs = options.windowInMs;\n    this._startInternal();\n    this.logRemaniningTokensPeriodically();\n  }\n\n  private logRemaniningTokensPeriodically() {\n    if (this.verbose) {\n      setInterval(() => {\n        if (this._timerId)\n          console.log(`TokenBucket: Remaining tokens: ${this._tokens}`);\n      }, 10000);\n    }\n  }\n\n  /**\n   * Force the bucket to wait until the specified amount of seconds have passed\n   * @param delayInMs How many miliseconds should be passed before the bucket is refilled\n   * @returns\n   */\n  forceWaitUntilMilisecondsPassed(delayInMs: number) {\n    if (this._ongoingForcedStop) return;\n    this._nextRefillDate = new Date(Date.now() + delayInMs);\n    if (this.verbose)\n      console.log(\n        `TokenBucket: Forcing stop. Will start to refill in ${Math.floor(delayInMs / 1000)} seconds`,\n      );\n    this._ongoingForcedStop = true;\n    this._tokens = 0;\n    this.stop();\n    setTimeout(() => {\n      this._tokens = this._capacity;\n      this._startInternal();\n      this._tryResolveWaiting();\n      this._ongoingForcedStop = false;\n      if (this.verbose) console.log('TokenBucket: Forced stop ended');\n    }, delayInMs);\n  }\n\n  validate(options: TokenBucketOptions) {\n    if (!options) throw new Error('Options are required');\n    if (options.capacity <= 0)\n      throw new Error('Capacity must be greater than 0');\n    if (options.fillPerWindow <= 0)\n      throw new Error('Fill per window must be greater than 0');\n    if (options.windowInMs <= 0)\n      throw new Error('Window in ms must be greater than 0');\n    if (\n      options.initialTokens !== undefined &&\n      (options.initialTokens < 0 || options.initialTokens > options.capacity)\n    )\n      throw new Error('Initial tokens must be between 0 and capacity');\n    if (options.fillPerWindow > options.capacity)\n      throw new Error('Fill per window must be less than or equal to capacity');\n  }\n\n  /**\n   * @returns Return this instance, to allow chaining\n   */\n  private _startInternal(): TokenBucket {\n    this._nextRefillDate = new Date(Date.now() + this._windowInMs);\n    if (!this._timerId) {\n      this._timerId = setInterval(() => {\n        this._nextRefillDate = new Date(Date.now() + this._windowInMs);\n\n        if (this._tokens < this._capacity) {\n          this._addToken();\n          this._tryResolveWaiting();\n        } else {\n          // Bucket is full, stop the timer.\n          this.stop();\n          if (this.verbose)\n            console.log('TokenBucket: Bucket is full, stopping the timer');\n        }\n      }, this._windowInMs);\n    }\n    return this;\n  }\n\n  start(): TokenBucket {\n    return this._startInternal();\n  }\n\n  stop(): void {\n    if (this._timerId) {\n      clearInterval(this._timerId as any);\n      this._timerId = null;\n    }\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get tokens(): number {\n    return this._tokens;\n  }\n\n  private _addToken(): void {\n    this._tokens = Math.min(this._tokens + this._fillPerWindow, this._capacity);\n  }\n\n  consume(amount: number = 1): boolean {\n    if (!this._timerId && !this._ongoingForcedStop) this._startInternal();\n    if (this._tokens >= amount) {\n      this._tokens -= amount;\n      return true;\n    }\n    return false;\n  }\n\n  async consumeAsync(amount: number = 1): Promise<boolean> {\n    if (!this._timerId && !this._ongoingForcedStop) this._startInternal();\n\n    if (this._tokens >= amount)\n      return await Promise.resolve(this.consume(amount));\n    else if (this.verbose) {\n      const miliSecondsRemaining = this._nextRefillDate?.getTime()\n        ? this._nextRefillDate.getTime() - Date.now()\n        : undefined;\n      const nextRefillInSecondsText = miliSecondsRemaining\n        ? Math.floor(miliSecondsRemaining / 1000)\n        : 'unknown';\n      console.log(\n        `TokenBucket: Not enough tokens now. Will refill in ${nextRefillInSecondsText} seconds.`,\n      );\n    }\n\n    return await new Promise<boolean>((resolve) => {\n      this._waitQueue.push(() => {\n        resolve(this.consume(amount));\n      });\n    });\n  }\n\n  private _tryResolveWaiting(): void {\n    while (this._tokens > 0 && this._waitQueue.length > 0) {\n      const resolver = this._waitQueue.shift();\n      if (resolver) resolver();\n    }\n  }\n}\n","import { TokenBucket } from '../tokenBucket/index.js';\nimport { type TokenBucketOptions } from '../tokenBucket/types.js';\nimport type { RetryOptions } from './types.js';\n\nconst defaultTokenBucketOptions: TokenBucketOptions = {\n  capacity: 10,\n  fillPerWindow: 1,\n  windowInMs: 100,\n};\n\nconst defaultRetryOptions: RetryOptions = {\n  maxRetries: 3,\n  minDelayInMs: 1000,\n  maxDelayInMs: 10000,\n  backoffFactor: 2,\n};\n\n/**\n * A class for making asynchronous calls with retry, concurrency, and rate limiting capabilities.\n * Creates an instance of AsyncCaller.\n * @param options - The options for configuring the AsyncCaller.\n * @param options.tokenBucketOptions - The options for configuring the rate limits.\n * @param options.tokenBucketOptions.capacity - The maximum number of requests allowed in a window.\n * @param options.tokenBucketOptions.fillPerWindow - The number of requests to allow per window. This determines the rate at which requests are allowed.\n * @param options.tokenBucketOptions.windowInMs - The size of the window in milliseconds.\n * @param options.tokenBucketOptions.initialTokens - The initial number of allowed requests. If not provided, it defaults to the capacity. Setting it to a lower value can be useful for gradually ramping up the rate.\n * @param options.retryOptions - The options for configuring the retry behavior.\n * @param options.concurrency - The maximum number of concurrent tasks allowed.\n *\n * @example\n * // Create an AsyncCaller with a simple rate limit of 10 requests per second\n * const asyncCaller = new AsyncCaller({\n *   tokenBucketOptions: {\n *     capacity: 10,\n *     fillPerWindow: 10,\n *     windowInMs: 1000,\n *   },\n * });\n *\n * @example\n * // Create an AsyncCaller with a rate limit of 100 requests per minute, with a burst capacity of 20 requests\n * const asyncCaller = new AsyncCaller({\n *   tokenBucketOptions: {\n *     capacity: 20,\n *     fillPerWindow: 100,\n *     windowInMs: 60000,\n *   },\n * });\n */\nexport class AsyncCaller {\n  private readonly _tokenBucket: TokenBucket;\n  private readonly _retryOptions: RetryOptions;\n  private readonly _concurrency: number;\n  private runningTasks: number = 0;\n  private readonly queue: any[];\n  verbose: boolean;\n\n  constructor(\n    options?: {\n      tokenBucketOptions?: TokenBucketOptions;\n      retryOptions?: RetryOptions;\n      concurrency?: number;\n    },\n    verbose: boolean = false,\n  ) {\n    this.verbose = verbose;\n    this._tokenBucket = new TokenBucket(\n      options?.tokenBucketOptions ?? defaultTokenBucketOptions,\n      this.verbose,\n    );\n    this._retryOptions = options?.retryOptions ?? defaultRetryOptions;\n    this._concurrency = options?.concurrency ?? 5;\n    this.queue = [];\n  }\n\n  public async call<T>(fn: () => Promise<T>): Promise<T> {\n    await new Promise<void>((resolve) => {\n      this.queue.push(resolve);\n      this.processTaskQueue();\n    });\n    return await this.executeAndHandleErrors(fn);\n  }\n\n  private processTaskQueue() {\n    while (this.runningTasks < this._concurrency && this.queue.length > 0) {\n      this.runningTasks++;\n      const resolve = this.queue.shift();\n      if (resolve) {\n        if (this.verbose)\n          console.log(\n            `AsyncCaller: Running task... Concurrency: (${this.runningTasks} / ${this._concurrency}) (Queue length: ${this.queue.length})`,\n          );\n        resolve();\n      }\n    }\n  }\n\n  private async extractErrorMessageFromResponse(\n    response: any,\n  ): Promise<string | undefined> {\n    try {\n      const fetchResponse = response as Response;\n      const json = await fetchResponse.json();\n      if (json.error) return JSON.stringify(json.error);\n      if (json.message) return json.message;\n      if (json.error_message) return json.error_message;\n      if (json.errors) return JSON.stringify(json.errors);\n      else return undefined;\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  private async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    tryCount: number = 1,\n    lastResponse: any = undefined,\n    lastError: any = undefined,\n  ): Promise<T> {\n    let directlyReturnErrorAsResult = false;\n    while (!(await this._tokenBucket.consumeAsync()));\n    if (tryCount > this._retryOptions.maxRetries! + 1) {\n      if (this.verbose)\n        console.log('AsyncCaller: Max retries exceeded. Rejecting...');\n      let errorToThrow = new Error('Max retries exceeded.');\n      if (lastError) errorToThrow = lastError;\n      else if (lastResponse) {\n        const errorText =\n          await this.extractErrorMessageFromResponse(lastResponse);\n        if (errorText) errorToThrow = new Error(errorText);\n      }\n      throw errorToThrow;\n    }\n    return fn()\n      .then(async (result) => {\n        const fetchResult = result as Response;\n        if (this.isRateLimitedError(fetchResult)) {\n          const delay = this.calculateRetryDelay(tryCount, fetchResult.headers);\n          // eslint-disable-next-line promise/param-names\n          await new Promise<void>((innerResolve) =>\n            setTimeout(() => {\n              innerResolve();\n            }, delay),\n          );\n          return this.executeWithRetry(\n            fn,\n            tryCount + 1,\n            fetchResult,\n            lastError,\n          );\n        } else if (this.isClientSideError(fetchResult)) {\n          directlyReturnErrorAsResult = true;\n          throw result as Error;\n        } else return result;\n      })\n      .catch(async (err) => {\n        if (directlyReturnErrorAsResult) return err;\n        // if the error is thrown deliberetly in the previous block, rethrow it)\n        if (tryCount === this._retryOptions.maxRetries! + 1) {\n          if (this.verbose)\n            console.log('AsyncCaller: Max retries exceeded. Rejecting...');\n          throw err;\n        } else if (this.isRateLimitedError(err)) {\n          const delay = this.calculateRetryDelay(\n            tryCount,\n            err.headers ?? err.response?.headers,\n          );\n          // eslint-disable-next-line promise/param-names\n          await new Promise<void>((innerResolve) =>\n            setTimeout(() => {\n              innerResolve();\n            }, delay),\n          );\n          return this.executeWithRetry(fn, tryCount + 1, lastResponse, err);\n        } else if (this.isClientSideError(err)) throw err;\n        else {\n          const delay = this.calculateDefaultDelay(tryCount);\n          // eslint-disable-next-line promise/param-names\n          await new Promise<void>((innerResolve) =>\n            setTimeout(() => {\n              innerResolve();\n            }, delay),\n          );\n          return this.executeWithRetry(fn, tryCount + 1, err);\n        }\n      });\n  }\n\n  private async executeAndHandleErrors<T>(fn: () => Promise<T>): Promise<T> {\n    try {\n      const result = await this.executeWithRetry(fn, 1, undefined);\n      return result;\n    } finally {\n      this.runningTasks--;\n      this.processTaskQueue();\n    }\n  }\n\n  isClientSideError(errOrResponse: any): boolean {\n    const possibleProperties = this.extractStatusCodeProperties(errOrResponse);\n    for (const property of possibleProperties) {\n      if (property >= 400 && property < 500) {\n        if (this.verbose) {\n          console.log(\n            `AsyncCaller: Client side error detected. Status code: ${property}`,\n          );\n          console.log(JSON.stringify(errOrResponse));\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isRateLimitedError(errOrResponse: any): boolean {\n    const possibleProperties = this.extractStatusCodeProperties(errOrResponse);\n    for (const property of possibleProperties) {\n      if (property === 429) {\n        if (this.verbose)\n          console.log('AsyncCaller: Too many requests detected.');\n        return true;\n      }\n    }\n    return false;\n  }\n\n  extractStatusCodeProperties(err: any): number[] {\n    const statusCodes = [\n      err?.status,\n      err?.response?.status,\n      err?.statuscode,\n      err?.response?.statuscode,\n    ];\n\n    return statusCodes.filter(\n      (status) => typeof status === 'number' && !Number.isNaN(status),\n    ) as number[];\n  }\n\n  private calculateRetryDelay(completedTryCount: number, headers: any): number {\n    // check if headers has a get function\n    if (headers) {\n      let retryAfterHeader;\n      if (typeof headers.get === 'function')\n        retryAfterHeader = headers.get('Retry-After');\n      else retryAfterHeader = headers['Retry-After'];\n\n      if (retryAfterHeader) {\n        const delay = Number.parseInt(retryAfterHeader) * 1000; // Convert seconds to milliseconds\n        if (!Number.isNaN(delay)) {\n          this._tokenBucket.forceWaitUntilMilisecondsPassed(delay);\n          return delay;\n        } else if (Date.parse(retryAfterHeader) > 0) {\n          const now = new Date().getTime();\n          const retryAfter = new Date(retryAfterHeader).getTime();\n          const delay = Math.max(retryAfter - now, 0);\n          this._tokenBucket.forceWaitUntilMilisecondsPassed(delay);\n          return delay;\n        } else {\n          // If the Retry-After header value cannot be parsed, fall back to the default back-off strategy\n          return this.calculateDefaultDelay(completedTryCount);\n        }\n      } else return this.calculateDefaultDelay(completedTryCount);\n    } else {\n      // If no specific Retry-After header is found, use the default back-off strategy\n      return this.calculateDefaultDelay(completedTryCount);\n    }\n  }\n\n  private calculateDefaultDelay(completedTryCount: number): number {\n    // Exponential back-off strategy based on the RetryOptions\n    const delay = Math.min(\n      this._retryOptions.minDelayInMs! *\n        this._retryOptions.backoffFactor! ** (completedTryCount - 1),\n      this._retryOptions.maxDelayInMs!,\n    );\n    return delay;\n  }\n}\n","export enum TimeUnit {\n  Milliseconds = 1,\n  Seconds = 1000,\n  Minutes = 60000,\n  Hours = 3600000,\n  Days = 86400000,\n}\n\nexport interface RetryOptions {\n  /**\n   * The maximum number of retries. Default is 3.\n   */\n  maxRetries?: number;\n  /**\n   * The minimum delay between retries in milliseconds. Default is 1000.\n   */\n  minDelayInMs?: number;\n  /**\n   * The maximum delay between retries in milliseconds. Default is 10000\n   */\n  maxDelayInMs?: number;\n  /**\n   * The factor by which the delay should be increased after each retry. Default is 2.\n   */\n  backoffFactor?: number;\n}\n","export function removeMatterCode(caseName?: string): string {\n  if (!caseName) return '';\n  const regex = /(\\d{4})([A-Z]{3})(\\d{2})(\\s*)(.*)/;\n\n  const match = caseName.match(regex);\n\n  if (!match || match.length < 6) return caseName;\n\n  const numberPart = match[3];\n  if (numberPart === '01') return match[5];\n  return match[5].trim() + ' ' + numberPart;\n}\n"],"mappings":"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","names":["TokenBucket","options","verbose","delayInMs","amount","miliSecondsRemaining","nextRefillInSecondsText","resolve","resolver","defaultTokenBucketOptions","defaultRetryOptions","AsyncCaller","options","verbose","TokenBucket","fn","resolve","response","json","tryCount","lastResponse","lastError","directlyReturnErrorAsResult","errorToThrow","errorText","result","fetchResult","delay","innerResolve","err","errOrResponse","possibleProperties","property","status","completedTryCount","headers","retryAfterHeader","now","retryAfter","TimeUnit","removeMatterCode","caseName","regex","match","numberPart"]}